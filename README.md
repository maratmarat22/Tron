# Игра ТРОН

ТРОН — это аркадная игра для двоих игроков, где каждый управляет квадратиком, оставляя за собой стену. Цель игры — прожить дольше противника, избегая столкновений со стенами и маршрутом оппонента, а также создавая ловушки для противника с помощью собственной стены.

В этом проекте мы реализовали игру ТРОН на языке C#

</br>
<p align="center">
<img src="Tron_general.png" alt="ТРОН"
title="ТРОН" width="1000" align="middle" />
</p>
</br>

## Реализация игры ТРОН

Наша реализация игры ТРОН включает создание двумерной сетки, где каждая ячейка представляет собой положение на игровом поле. Клетка и след игрока представлен серией соединённых ячеек на сетке, которые обновляются при каждом движении. Игра продолжается до тех пор, пока один из игроков не врежется в стену или в маршрут противника, после чего выигрывает другой игрок.

В игре доступны три режима: синглплеер с соперником-компьютером, локальный кооператив и мультиплеер

</br>
<p align="center">
<img src="Tron.png" alt="ТРОН"
title="ТРОН" width="1000" align="middle" />
</p>
</br>

## Протокол сетевого взаимодействия
Данный протокол описывает процесс взаимодействия клиента и сервера в игровой сессии, основанный на передаче сообщений (Message).

### 1.Название протокола
TRON Message Protocol

### 2.Описание формата сообщений
Message состоит из двух частей: Header и Payload — заголовок и полезная нагрузка сообщения соответственно. Формат данных Header — Enum Header, формат данных PAYLOAD — string[]. При отправлении сообщение сериализуется из Message в строку, при получении — десериализуется из строки в Message. 

Пример сообщения:

    Message request = new(Header.ConnectionCheck, []);

### 3.Примеры запросов и ответов 

1. Регистрация

    Клиент → Сервер: Запрос регистрации:
   - Заголовок: Register
   - Тело: [username]

    Сервер → Клиент: Ответ с подтверждением:
   - Заголовок: Ok
   - Тело: [Register]
     
2. Запрос лобби

    Клиент → Сервер: Запрос лобби:
    - Заголовок: FetchLobbies
    - Тело: []

    Сервер → Клиент: Ответ с полезной нагрузкой:
    - Заголовок: Ok
    - Тело: [FetchLobbies, lobbies (сериализованные)]

### 4.Описание логики обработки на сервере 

Сообщения можно разделить на три группы:
   - Легкие: сервер обрабатывает сообщение и возвращает клиенту только подтверждение операции;
   - Сложные: сервер обрабатывает сообщение и возвращает клиенту подтверждение операции и полезную нагрузку;
   - Нестандартные: поведение сервера может включать в себя отправление запросов другим клиентам/серверам или изменение принципа работы сервера.

При получении сообщения сервер подбирает необходимый обработчик и по необходимости выделяет ему состояние сессии, текущий Unicaster или Multicaster. Обработчик возвращает ответ, который сервер отправляет обратно клиенту. Дальнейшее поведение сервера зависит от типа запроса. Например, при запросе CreateLobby, после успешной обработки сообщения и отправки ответа клиенту сервер переключается в мультикаст-режим.

### 5.Описание логики обработки ошибок

1. Ошибка при соединении к серверу:
Если клиент открыл сокет и не смог подключиться к серверу, то этот сокет закрывается. Клиентское приложение выведет предупреждение об ошибке.

2. Таймаут ожидания:
Если клиент не получил ответ от сервера в течение 1000 мс (ReceiveTimeout), то клиент получает null, который впоследствии обрабатывается.

3. Ошибка при авторизации:
Если сервер не смог авторизовать клиента (при LogIn -- не нашел имени клиента в базе, при Register -- нашел уже существующего клиента с таким именем), то сервер не начнет слушать этого клиента и будет ждать очередного запроса авторизации.

3. Ошибка при обработке сообщения:
Если сервер не смог обработать сообщение, то он отправляет клиенту сообщение Nok (Not ok).

### Структура проекта
1. Проект Tron.Client.Application
Содержит логику для клиентского приложения
- Views: Содержит все существующие экраны
- ViewModels: Содержит логику взаимодействия для всех существующих экранов
Использует проекты:
- Tron.Client.Networking -- для подключения к серверу;
- Tron.Common -- для общих с сервером типов данных и возможности юникаста.

2. Проект Tron.Client.Networking
Содержит логику соединения с сервером

3. Проект Tron.Server
Содержит логику обработки сообщений от клиентов
- Core: Содержит логику обработки сообщений и работы серверного приложения в целом
- Networking: Содержит логику соединения с клиентом и мультикаста
- Persistence: Содержит логику для работы с базой данных
Использует проекты:
- Tron.Common -- для общих с клиентом типов данных и возможности юникаста.

4. Проект Tron.Common
Содержит общие для клиента и сервера типы данных
- Entities: содержит игровые сущности (направление, лобби, координаты)
- Messages: содержит тип сообщения (Message) и всевозможные заголовки
- Networking: содержит логику для возможности юникаста и методы-расширения для сокетов
- Persistence: содержит логику для работы с файлами и .txt файл с сокетом сервером
